# SpbTechRun: Интеллектуальная система рекомендаций сопутствующих товаров

## О проекте

**SpbTechRun** — это полнофункциональная система рекомендаций товаров для розничной сети строительных материалов МАКСИДОМ. Система решает задачу автоматического подбора сопутствующих товаров для этапа ремонта "White Box" (черновая отделка): наливные полы, выравнивание стен, монтаж перегородок.

**Ссылка на датасеты:** https://drive.google.com/drive/folders/1raoqlnlr_Equ8GGNeZUcAkfdRVh4iHx3?usp=drive_link

### Ключевая бизнес-задача

При покупке строительных материалов клиенту необходимо приобрести не только основной товар (например, штукатурку), но и весь комплект сопутствующих материалов: грунтовку, шпатели, правила, ёмкости для замеса. Система автоматически определяет сценарий ремонта и рекомендует недостающие товары, повышая средний чек и удобство для покупателя.

### Главные особенности решения

- **Работа в закрытом контуре** — все вычисления происходят локально, без обращения к внешним API
- **Локальные ML-модели** — интеграция с Ollama для генерации эмбеддингов
- **Непрерывное обучение** — система улучшается на основе обратной связи пользователей без переобучения нейросети
- **Два типа рекомендаций** — по товару (на странице товара) и по сценарию (для завершения набора)
- **Время ответа < 5 секунд** — быстрый поиск через FAISS-индекс

---

## Архитектура системы

Проект построен на микросервисной архитектуре с четырьмя основными компонентами:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Frontend (React + Vite)                           │
│                              http://localhost:3000                          │
└─────────────────────────────┬───────────────────────────────────────────────┘
                              │
          ┌───────────────────┴───────────────────┐
          ▼                                       ▼
┌─────────────────────────┐             ┌─────────────────────────┐
│   Backend API (Go/Gin)  │             │  ML Service (FastAPI)   │
│   http://localhost:8080 │             │  http://localhost:8000  │
└───────────┬─────────────┘             └───────────┬─────────────┘
            │                                       │
            │  ┌───────────────────────────────┐   │
            └──►        PostgreSQL 16          ◄───┘
               │      (общая база данных)      │
               └───────────────────────────────┘
                              │
    ┌─────────────────────────┼─────────────────────────┐
    ▼                         ▼                         ▼
┌─────────┐            ┌─────────────┐           ┌─────────┐
│  Redis  │            │Elasticsearch│           │ Ollama  │
│  Cache  │            │   Search    │           │   LLM   │
└─────────┘            └─────────────┘           └─────────┘
```

### Почему выбрана такая архитектура

1. **Разделение ответственности** — Backend обрабатывает e-commerce логику (каталог, корзина, заказы), ML-сервис фокусируется на рекомендациях
2. **Независимое масштабирование** — ML-сервис можно масштабировать отдельно при росте нагрузки
3. **Технологическая гибкость** — Go для высоконагруженного API, Python для ML благодаря богатой экосистеме
4. **Простота развёртывания** — Docker Compose для единой оркестрации всех сервисов

---

## Технологический стек

### Backend (Go)
| Технология | Назначение |
|------------|------------|
| **Go 1.25** | Основной язык — выбран за производительность и простоту деплоя |
| **Gin** | HTTP-фреймворк — легковесный, высокопроизводительный |
| **PostgreSQL** | Основная БД — надёжное хранение товаров, заказов, пользователей |
| **Redis** | Кэширование — сессии, корзина, кэш категорий |
| **Elasticsearch** | Полнотекстовый поиск — быстрый поиск товаров с фасетами |
| **golang-jwt** | Аутентификация — JWT-токены для защиты API |
| **golang-migrate** | Миграции БД — версионирование схемы данных |

### ML-сервис (Python)
| Технология | Назначение |
|------------|------------|
| **FastAPI** | Async-фреймворк — высокая производительность для ML-эндпоинтов |
| **SQLAlchemy 2.0** | Async ORM — работа с PostgreSQL |
| **FAISS** | Векторный поиск — быстрый поиск ближайших соседей в пространстве эмбеддингов |
| **Ollama** | Локальные LLM — генерация эмбеддингов через nomic-embed-text |
| **NumPy** | Вычисления — операции с векторами, cosine similarity |

### Frontend (TypeScript)
| Технология | Назначение |
|------------|------------|
| **React 19** | UI-библиотека — компонентный подход, hooks |
| **Vite** | Сборщик — мгновенный HMR, быстрая сборка |
| **TypeScript** | Типизация — надёжность кода, автодополнение |
| **TanStack Query** | Кэширование данных — автоматическое управление запросами |
| **Zustand** | State-менеджмент — простая глобальная state-машина |
| **Tailwind CSS** | Стилизация — utility-first подход |
| **shadcn/ui** | UI-компоненты — готовые, кастомизируемые компоненты |

### Инфраструктура
| Технология | Назначение |
|------------|------------|
| **Docker Compose** | Оркестрация — запуск всех сервисов одной командой |
| **Ollama** | LLM-платформа — локальный запуск языковых моделей |
| **Nginx** | Статика — раздача фронтенда в production |

---

## ML-система рекомендаций

### Два типа рекомендаций

Система поддерживает два типа рекомендаций для разных пользовательских сценариев:

#### Тип 1: Рекомендации на странице товара

**Где показывается:** Страница товара `/product/{id}`
**API:** `GET /recommendations/{product_id}`
**Что возвращает:** 20 сопутствующих товаров

Когда покупатель открывает страницу товара (например, "Штукатурка KNAUF Ротбанд"), система показывает сопутствующие товары: грунтовку, шпатели, правила, ёмкости — всё, что нужно для работы с этим товаром.

**Алгоритм:**
1. Определяется сценарий ремонта по категории товара (штукатурка → "Выравнивание стен")
2. Из смежных групп сценария (грунты, инструменты, ёмкости) выбираются кандидаты
3. Каждый кандидат получает скор на основе: семантической близости, накопленного фидбека, наличия скидки
4. Возвращаются 20 товаров с наивысшим скором

#### Тип 2: Рекомендации по сценарию

**Где показывается:** Главная страница, карусель сценариев
**API:** `GET /scenarios/{id}/recommendations?cart_product_ids=...`
**Что возвращает:** Недостающие товары для завершения сценария

Система анализирует, какие категории товаров уже есть в корзине, и рекомендует докупить недостающее для завершения сценария.

**Пример:**
- В корзине: Ровнитель PLITONIT Universal
- Определённый сценарий: "Монтаж наливного пола" (прогресс 17%)
- Рекомендации: грунт, ведро, валик игольчатый, насадка на миксер

### Формула скоринга

Итоговый рейтинг товара рассчитывается по формуле:

```
score = 0.5 (база)
      + similarity × 0.3      # семантическая близость эмбеддингов
      + pair_feedback × 0.4   # фидбек для пары "основной → рекомендованный"
      + scenario_feedback × 0.2  # фидбек в контексте сценария
      + discount × 0.1        # бонус за скидку
```

**Семантическая близость** — cosine similarity между эмбеддингами товаров, сгенерированными через Ollama (nomic-embed-text, 768 измерений).

**Pair feedback** — накопленная статистика по конкретной паре товаров. Если пользователи часто подтверждают, что "к штукатурке KNAUF подходит грунт CERESIT", эта пара получает буст.

**Scenario feedback** — статистика по товару в контексте сценария. Если товар хорошо оценивают в сценарии "Выравнивание стен", он поднимается в выдаче для этого сценария.

### Эволюция системы: от холодного старта к персонализации

#### День 1 (Холодный старт)

В начале работы системы нет данных о предпочтениях пользователей. Рекомендации строятся только на:
- **Эмбеддингах** — семантическая близость товаров (основной фактор)
- **Правилах категорий** — экспертные знания о совместимости (штукатурка → шпатель)

Качество рекомендаций приемлемое, но не персонализированное.

#### День 7+ (Накоплен глобальный фидбек)

После сотен оценок от пользователей:
- Товары с высоким % одобрения поднимаются в выдаче
- Товары с низким % опускаются или исчезают
- Система начинает "понимать", какие сочетания реально работают

**Важно:** "Обучение" системы — это НЕ переобучение нейросети. Ollama-модель остаётся замороженной. Обучение сводится к накоплению статистики в базе данных, что позволяет обновлять рекомендации мгновенно.

### Эмбеддинги товаров

Для каждого товара формируется текстовое представление, включающее:
- Название товара
- Категория и путь в иерархии
- Бренд/производитель
- Параметры (объём, вес, материал и т.д.)
- Описание

Пример:
```
"Грунтовка KNAUF Tiefengrund универсальная 10л.
Категория: Грунтовки для внутренних работ.
Применение: для стен, для потолков, для гипсокартона.
Бренд: KNAUF. Объём: 10 литров."
```

Текст передаётся в Ollama (модель nomic-embed-text), которая возвращает вектор из 768 чисел. Эти векторы хранятся в PostgreSQL и индексируются через FAISS для быстрого поиска ближайших соседей.

### Сценарии ремонта (White Box)

Система включает три предопределённых сценария для этапа черновой отделки:

#### 1. Монтаж наливного пола

| Группа | Категории | Обязательно |
|--------|-----------|-------------|
| Основа | Ровнители, Смеси для пола | Да |
| Грунты | Грунтовки, Гидроизоляция | Да |
| Ёмкости | Вёдра, Контейнеры | Да |
| Валики | Валики игольчатые | Да |
| Миксер | Насадки на миксер | Да |
| Уровни | Уровни измерительные | Нет |
| Плёнка | Плёнка техническая, Лента демпферная | Нет |

#### 2. Монтаж перегородок

| Группа | Категории | Обязательно |
|--------|-----------|-------------|
| Основа | Газоблоки, Гипсокартон, ПГП | Да |
| Клей | Клей для газоблоков, Клей монтажный | Да |
| Грунты | Грунтовки | Да |
| Шпатлёвка | Шпатлёвки | Да |
| Ёмкости | Вёдра | Да |
| Миксер | Насадки на миксер | Да |

#### 3. Выравнивание стен

| Группа | Категории | Обязательно |
|--------|-----------|-------------|
| Основа | Штукатурки | Да |
| Грунты | Грунтовки, Бетонконтакт | Да |
| Шпатлёвка | Шпатлёвки | Да |
| Ёмкости | Вёдра | Да |
| Правила | Правила строительные | Да |
| Шпатели | Шпатели | Да |
| Миксер | Насадки на миксер | Да |
| Армирование | Сетка, Серпянка | Нет |

---

## Система фидбека

### Сбор обратной связи

На каждой карточке рекомендованного товара пользователь может оценить релевантность:
- **"Подошёл"** — положительный фидбек, товар поднимается в рейтинге
- **"Не подошёл"** — отрицательный фидбек, товар опускается

### Хранение данных

**Сырой фидбек** — каждая оценка сохраняется с контекстом:
```sql
CREATE TABLE product_pair_feedback (
    user_id INT,
    main_product_id INT,
    recommended_product_id INT,
    feedback_type VARCHAR(20),  -- 'positive' / 'negative'
    context VARCHAR(50),        -- 'product_page' / 'scenario_page'
    created_at TIMESTAMP
);
```

**Агрегированная статистика** — для быстрого доступа при ранжировании:
```sql
CREATE TABLE pair_feedback_stats (
    main_product_id INT,
    recommended_product_id INT,
    positive_count INT,
    negative_count INT,
    PRIMARY KEY (main_product_id, recommended_product_id)
);
```

### Байесовское сглаживание

Чтобы один случайный лайк не давал 100% и один дизлайк не давал 0%, используется формула сглаживания:

```
approval_rate = (positive_count + 1) / (total_count + 2)
```

Это обеспечивает:
- Новый товар без статистики получает нейтральный рейтинг 0.5
- Товар с 10 лайками и 0 дизлайков получает ~0.92 (не 100%)
- Товар с 0 лайков и 10 дизлайков получает ~0.08 (не 0%)

---

## Полнотекстовый поиск

### Elasticsearch интеграция

Для быстрого поиска товаров по запросу используется Elasticsearch:

- **Индексация** — товары автоматически добавляются в индекс через паттерн Outbox
- **Поиск** — полнотекстовый поиск с учётом морфологии русского языка
- **Фасеты** — агрегации по категориям, брендам, ценовым диапазонам

### Outbox Pattern

При изменении товара в PostgreSQL:
1. Запись попадает в таблицу `outbox`
2. Background-воркер читает `outbox` и отправляет в Elasticsearch
3. Запись помечается как обработанная

Это обеспечивает:
- **Eventual consistency** — данные синхронизируются асинхронно
- **Надёжность** — при падении Elasticsearch данные не теряются
- **Производительность** — основной запрос не блокируется на индексацию

---

## API эндпоинты

### Backend API (Go, порт 8080)

#### Каталог товаров
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/api/products` | Список товаров с пагинацией |
| GET | `/api/products/:id` | Детали товара |
| GET | `/api/categories` | Дерево категорий |
| GET | `/api/search` | Полнотекстовый поиск с фильтрами |

#### Аутентификация
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| POST | `/api/auth/register` | Регистрация |
| POST | `/api/auth/login` | Вход (возвращает JWT) |
| GET | `/api/auth/profile` | Профиль пользователя |

#### Корзина
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/api/cart` | Получить корзину |
| POST | `/api/cart/items` | Добавить товар |
| PUT | `/api/cart/items/:id` | Изменить количество |
| DELETE | `/api/cart/items/:id` | Удалить товар |

#### Заказы
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/api/orders` | История заказов |
| POST | `/api/orders` | Создать заказ из корзины |

### ML API (Python, порт 8000)

#### Рекомендации
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/recommendations/{product_id}` | 20 сопутствующих товаров |
| GET | `/scenarios` | Список сценариев |
| GET | `/scenarios/{id}` | Детали сценария с группами |
| GET | `/scenarios/{id}/recommendations` | Недостающие товары |
| GET | `/recommendations/scenario/auto` | Авто-определение сценария по корзине |

#### Фидбек
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| POST | `/feedback` | Отправить оценку рекомендации |

#### Статистика
| Метод | Эндпоинт | Описание |
|-------|----------|----------|
| GET | `/stats` | Статистика системы |
| GET | `/health` | Проверка работоспособности |

---

## Структура базы данных

### Основные таблицы

```sql
-- Иерархия категорий
categories (id, name, parent_id)

-- Каталог товаров
products (id, name, description, price, category_id, params JSONB, picture)

-- Акции и скидки
promos (id, product_id, discount_price, start_date, end_date)

-- Пользователи
users (id, email, password_hash, created_at)

-- Корзина (поддерживает анонимных и авторизованных)
cart_items (id, user_id, session_id, product_id, quantity)

-- Заказы
orders (id, user_id, status, total, created_at)
order_items (id, order_id, product_id, quantity, price)
```

### ML-таблицы

```sql
-- Эмбеддинги товаров (768-мерные векторы)
product_embeddings (product_id, embedding FLOAT[])

-- Сырой фидбек по парам товаров
product_pair_feedback (main_product_id, recommended_product_id, feedback_type, user_id, created_at)

-- Агрегированная статистика пар
pair_feedback_stats (main_product_id, recommended_product_id, positive_count, negative_count)

-- Фидбек по сценариям
scenario_feedback (scenario_id, group_name, product_id, feedback_type, user_id)
scenario_feedback_stats (scenario_id, group_name, product_id, positive_count, negative_count)

-- Статистика совместных покупок (рассчитывается из order_items)
copurchase_stats (product_id_1, product_id_2, copurchase_count)
```

---

## Запуск проекта

### Требования

- Docker и Docker Compose
- Ollama (для генерации эмбеддингов) — нужен только при первом запуске
- 8+ GB RAM

### Вариант 1: Первый запуск (генерация эмбеддингов)

Если у вас нет готовых эмбеддингов, нужно сгенерировать их через Ollama.

**Шаг 1: Установка и запуск Ollama (на Mac рекомендуется нативно для GPU-ускорения)**

```bash
# Установка Ollama
brew install ollama

# Запуск сервера (в отдельном терминале)
ollama serve

# Скачивание модели для эмбеддингов (~274 MB)
ollama pull nomic-embed-text
```

**Шаг 2: Запуск сервисов**

```bash
# Запуск всех сервисов
docker-compose up -d

# Проверка что всё поднялось
docker-compose ps
```

**Шаг 3: Загрузка данных (если БД пустая)**

```bash
cd data

# Установка зависимостей
pip install -r requirements.txt

# Загрузка товаров в PostgreSQL
python load_data.py
```

**Шаг 4: Генерация эмбеддингов**

```bash
# Генерация эмбеддингов для всех товаров (~10-30 минут)
docker exec -it spbtechrun-recommendations-1 python -m app.generate_embeddings
```

**Шаг 5: Экспорт эмбеддингов (для переноса на другой ПК)**

```bash
cd data
python export_embeddings.py
# Создаст файл embeddings.json (~50-100 MB)
```

После генерации Ollama можно остановить — он больше не нужен для работы рекомендаций.

---

### Вариант 2: Запуск с готовыми эмбеддингами (перенос на другой ПК)

Если у вас есть файл `embeddings.json` с готовыми эмбеддингами.

**Шаг 1: Запуск сервисов**

```bash
docker-compose up -d
```

**Шаг 2: Загрузка данных**

```bash
cd data
pip install -r requirements.txt
python load_data.py
```

**Шаг 3: Импорт эмбеддингов**

```bash
cd data
python import_embeddings.py
# Загрузит эмбеддинги из embeddings.json в PostgreSQL
```

**Шаг 4: Перезапуск ML-сервиса**

```bash
docker-compose restart recommendations
```

Готово! Ollama не нужен — система работает на готовых эмбеддингах.

---

### Обновление статистики совместных покупок

Система использует данные о совместных покупках для улучшения рекомендаций. По мере накопления заказов рекомендуется периодически обновлять статистику:

```bash
# Пересчёт co-purchase статистики из истории заказов
docker exec spbtechrun-recommendations-1 python -m app.update_copurchase
```

Это обновит таблицу `copurchase_stats`, и товары, которые часто покупают вместе, получат boost в ранжировании. Рекомендуется запускать после накопления новых заказов (например, раз в день через cron).

---

### Доступ к сервисам

| Сервис | URL |
|--------|-----|
| Frontend | http://localhost:3000 |
| Backend API | http://localhost:8080/api |
| ML API | http://localhost:8000 |
| Elasticsearch | http://localhost:9200 |

### Проверка работоспособности

```bash
# Проверка эмбеддингов в БД
docker exec spbtechrun-postgres-1 psql -U postgres -d spbtechrun \
  -c "SELECT COUNT(*) FROM product_embeddings"

# Тест API рекомендаций
curl http://localhost:8080/api/recommendations/1

# Тест сценариев
curl http://localhost:8080/api/scenarios
```

### Загрузка данных из YML-фида

```bash
# Парсинг YML-фида МАКСИДОМ (Jupyter Notebook)
cd data
jupyter notebook Maxidom_YML_parser.ipynb

# Загрузка CSV в PostgreSQL
python load_data.py
```

---

## Конфигурация

### Переменные окружения Backend

```env
HTTP_PORT=8080
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=spbtechrun
REDIS_HOST=redis
REDIS_PORT=6379
ELASTIC_URL=http://elasticsearch:9200
RECOMMENDATIONS_URL=http://recommendations:8000
JWT_SECRET=your-secret-key
```

### Переменные окружения ML-сервиса

```env
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=spbtechrun
OLLAMA_URL=http://ollama:11434
OLLAMA_MODEL=nomic-embed-text
```

---

## Структура проекта

```
SpbTechRun/
├── backend/                    # Go backend сервис
│   ├── cmd/server/            # Точка входа
│   ├── internal/
│   │   ├── config/            # Конфигурация
│   │   ├── handler/           # HTTP-обработчики
│   │   ├── service/           # Бизнес-логика
│   │   ├── repository/        # Работа с БД
│   │   ├── model/             # Доменные модели
│   │   ├── cache/             # Redis-кэш
│   │   └── search/            # Elasticsearch
│   └── migrations/            # SQL-миграции
│
├── recommendations/            # Python ML-сервис
│   └── app/
│       ├── api/               # FastAPI роуты
│       ├── services/          # Логика рекомендаций
│       │   ├── product_recommender.py   # Тип 1
│       │   ├── scenario_recommender.py  # Тип 2
│       │   └── scenarios.py             # Определения сценариев
│       ├── core/              # Эмбеддинги, конфигурация
│       └── db/                # SQLAlchemy модели
│
├── frontend/                   # React приложение
│   └── src/
│       ├── pages/             # Страницы приложения
│       ├── components/        # UI-компоненты
│       ├── api/               # API-клиенты
│       ├── hooks/             # React hooks
│       └── store/             # Zustand stores
│
├── data/                       # Обработка данных
│   ├── Maxidom_YML_parser.ipynb
│   ├── load_data.py
│   ├── export_embeddings.py    # Экспорт эмбеддингов
│   └── import_embeddings.py    # Импорт эмбеддингов
│
└── docker-compose.yml          # Оркестрация
```

---

## Соответствие критериям оценки

### 1. Анализ данных и формулирование гипотез

- Проведён анализ YML-фида МАКСИДОМ
- Выявлены ключевые признаки для определения схожести: категория, параметры товара, семантическое описание
- Сформулированы гипотезы о сценариях ремонта и группах товаров

### 2. Разработка и обучение модели

- Реализована генерация эмбеддингов через локальную модель Ollama (nomic-embed-text)
- Создан механизм перерасчёта рейтинга на основе пользовательских подтверждений
- Система обучается непрерывно без переобучения нейросети

### 3. API рекомендаций

- `GET /recommendations/{product_id}` — 20 похожих товаров с сортировкой по рейтингу
- `POST /feedback` — фиксация пользовательского выбора
- Время ответа < 5 секунд благодаря FAISS-индексу

### 4. Визуализация результатов

- Веб-интерфейс для выбора товара из каталога
- Отображение 20 рекомендаций с рейтингом схожести
- Возможность оценки релевантности (подошёл/не подошёл)
- Визуализация признаков: категория, % одобрения, семантическая близость

### 5. Технические требования

- Работа в закрытом контуре — все вычисления локальные
- Интеграция с Ollama для локального запуска LLM
- Полный сценарий "Монтаж перегородок" интегрирован

---

## Дальнейшее развитие

1. **Дополнительные сценарии** — этапы Black Box и Finishing
2. **Персонализация** — учёт истории покупок и предпочтений пользователя
3. **A/B тестирование** — сравнение алгоритмов ранжирования
4. **ML-модель ранжирования** — обучение LightGBM/CatBoost на накопленном фидбеке
5. **Административная панель** — управление сценариями и правилами

---

## Лицензия

Проект разработан для хакатона SPB Tech Run 2025.

## Команда

Разработано командой для конкурса МАКСИДОМ.
