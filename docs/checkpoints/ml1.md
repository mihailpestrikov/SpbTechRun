 ---
План реализации системы ML-рекомендаций

Текущее состояние

Готово:
- Frontend: React-приложение с витриной магазина, страницей товара, поиском
- Backend: Go + Gin, PostgreSQL, Redis, Elasticsearch для поиска
- Хуки useRecommendations и useFeedback уже существуют на фронтенде
- Backend handler /recommendations/:product_id и /feedback созданы, но пустые (TODO)
- Страница товара уже отображает блок рекомендаций с thumbs up/down

Нужно реализовать:
1. ML-сервис на Python (FastAPI)
2. Генерация эмбеддингов товаров через Ollama
3. Система ранжирования рекомендаций
4. Сбор и обработка фидбека

  ---
Шаг 1: Инфраструктура ML-сервиса

Задачи:
1. Добавить сервис ollama в docker-compose.yml
2. Создать директорию ml-service/ с FastAPI приложением
3. Создать таблицы в PostgreSQL:
   - product_embeddings — хранение векторов
   - feedback — сырой фидбек пользователей
   - feedback_stats — агрегированная статистика пар товаров
   - category_rules — правила совместимости категорий

Структура ml-service:
ml-service/
├── app/
│   ├── main.py           # FastAPI приложение
│   ├── models.py         # Pydantic модели
│   ├── embeddings.py     # Работа с Ollama
│   ├── recommender.py    # Алгоритм рекомендаций
│   ├── feedback.py       # Обработка фидбека
│   └── database.py       # Подключение к PostgreSQL
├── requirements.txt
└── Dockerfile

  ---
Шаг 2: Генерация эмбеддингов

Задачи:
1. Скрипт для генерации текстовых представлений товаров:
   - Название + категория + бренд + описание + параметры
2. Вызов Ollama API (nomic-embed-text модель) для генерации эмбеддингов
3. Сохранение эмбеддингов в таблицу product_embeddings
4. Построение FAISS индекса для быстрого поиска

Формат текста для эмбеддинга:
{name}. Категория: {category_path}. Бренд: {vendor}. {description}. Параметры: {params}

  ---
Шаг 3: Холодный старт рекомендаций

Алгоритм:
1. Получить эмбеддинг основного товара
2. Найти 100 ближайших товаров через FAISS (cosine similarity)
3. Отфильтровать товары из той же категории (убираем аналоги)
4. Применить правила совместимости категорий (из category_rules)
5. Вернуть топ-20 отсортированных по score

API эндпоинт:
GET /recommendations/{product_id}
→ { recommendations: [{ product: {...}, score: 0.92, reason: "Подходит для работы с..." }] }

  ---
Шаг 4: Правила совместимости категорий

Задачи:
1. Проанализировать категории в базе (White Box этап)
2. Составить справочник совместимых категорий:
   - Штукатурки → Шпатели, Грунтовки, Маяки, Миксеры
   - Наливной пол → Игольчатые валики, Грунтовки, Ёмкости
   - Гипсокартон → Профили, Саморезы, Шпаклёвка, Серпянка
   - И т.д.
3. Заполнить таблицу category_rules

  ---
Шаг 5: Система фидбека

При получении фидбека:
1. Сохранить в таблицу feedback (user_id, main_product_id, recommended_product_id, type)
2. Обновить счётчики в feedback_stats:
   - positive_count++ или negative_count++
3. Пересчитать approval_rate = (positive + 1) / (total + 2) (байесовское сглаживание)

Влияние на рекомендации:
- Пары с высоким approval_rate получают буст (множитель 1.5-2.0)
- Пары с низким approval_rate получают штраф (множитель 0.3-0.7)
- Пары без статистики — нейтральный множитель 1.0

  ---
Шаг 6: Интеграция с Backend

Задачи:
1. В Go backend добавить HTTP клиент к ML-сервису
2. Обновить RecommendationHandler.GetRecommendations:
   - Проксировать запрос к ML-сервису
   - Добавить user_id из JWT токена (если авторизован)
3. Обновить RecommendationHandler.PostFeedback:
   - Проксировать к ML-сервису
   - Добавить user_id

  ---
Шаг 7: Буст товаров со скидкой

Задачи:
1. При генерации рекомендаций проверять активные промо-акции
2. Товары со скидкой получают дополнительный множитель:
   - 10% скидка → множитель 1.1
   - 30% скидка → множитель 1.3
3. Добавить в ответ поле discount_price если есть акция

  ---
Шаг 8: Визуализация и "причины" рекомендаций

Задачи:
1. Генерировать осмысленные reason для каждой рекомендации:
   - "Необходим для работы со штукатуркой"
   - "95% пользователей одобрили эту рекомендацию"
   - "Популярный выбор в категории Шпатели"
   - "Скидка 25% до конца недели"
2. Фронтенд уже отображает rec.reason — нужно только отдавать с бэкенда

  ---
Шаг 9: (Опционально) Профили пользователей

Если останется время:
1. Таблица user_profiles с JSONB полями:
   - preferred_categories
   - preferred_brands
   - avg_price_preference
2. Обновлять при каждом фидбеке
3. Использовать при ранжировании (персональные множители)

  ---
Приоритеты

| Приоритет | Что делаем             | Результат                            |
  |-----------|------------------------|--------------------------------------|
| P0        | ML-сервис + эмбеддинги | Базовые рекомендации работают        |
| P0        | Правила категорий      | Показываем сопутствующие, не аналоги |
| P1        | Фидбек + статистика    | Система "обучается"                  |
| P1        | Буст скидок            | Выгодные товары выше                 |
| P2        | Причины рекомендаций   | Впечатляет жюри                      |
| P3        | Персонализация         | Если успеваем                        |
